\documentclass[sheet=2, english]{dexercise}

\title{Computer Security}
\author{Basil Ugbomoiko\\Daniel Knaack}
\setlist[enumerate, 2]{label={\sffamily\small\color{maincolor}\roman*}.}

\begin{document}

\task[Caches]

\begin{enumerate}
  \item
    \begin{enumerate}
      \item
        Given an address \texttt{addr[63:0]}, the bits \texttt{addr[s+b-1:b]}
        determine the cache set.
      \item
        In a cache with associativity $a$, an eviction set would consist of $a$
        cache lines.
    \end{enumerate}
  \item
    To find the area occupied by a 4 KB memory page in the cache, we first need
    to calculate the number of cache lines needed for a 4 KB page: $\frac{4\,
    \text{KB}}{64\, \text{B}} = 64$.
    Since each set has 8 ways, the area occupied would be $64 \times 8 = 512$
    cache lines.
  \item
    \begin{enumerate}
      \item
        It's not easy for an attacker to construct an eviction set for L2 and
        L3 caches because they are larger and more complex, making it harder to
        predict the cache behavior accurately.
      \item
        Huge-pages allocate memory in larger chunks, reducing the number of
        translation lookaside buffer (TLB) entries and, consequently, the
        number of cache lines needed to map a given memory region.
        This makes it harder for attackers to construct an eviction set because
        the relationship between virtual and physical addresses is less
        predictable.
    \end{enumerate}
  \item
    The cache line size for a modern Intel CPU is typically 64 bytes.

    If the first address in a cache line is 0x000, the last address within the
    same cache line would be 0x03F (since 64 in hexadecimal is 0x40, but
    counting starts from 0).
  \item
    \begin{enumerate}
      \item
        The address corresponding to \texttt{\&page[64]} would be
        \texttt{0x4000 + 64 * sizeof(char)} since \texttt{page} is a byte
        array. Given that \texttt{sizeof(char)} is typically 1, the address
        would be \texttt{0x4000 + 64 = 0x4040}.
      \item
        Technically, the \texttt{+} operator has lower precedence than the
        left-shift operator.
        This means that the actual address is \texttt{\&page[1~<<~(7+1)~<<~6]}
        instead of \texttt{\&page[(1<<7)~+~(1<<6)]}.
        Therefore, the address is \texttt{0x4000 + (1 << 8 << 6) = 0x4000 +
        0x4000 = 0x8000} instead of \texttt{0x4000 + 0xc0 = 0x40c0}.

        In this particular case, the six least-significant bits of the address
        represent the offset in the cache line, because each cache line has
        $64$ bytes.
        The next two bits represent the cache set index.
        To determine the cache set of each address, we have to look at the bits
        \texttt{addr[8:6]} of each address.
        Therefore, the address \texttt{0x8000} is cached in cache set 0 and
        \texttt{0x40c0} is cached in cache set 3.
    \end{enumerate}
  \item
    To fill cache set 0 completely with an associativity of 8, we need to
    allocate 8 memory pages since each set can hold 8 cache lines, one from
    each memory page.
\end{enumerate}

\task[Flush+Reload]

\begin{enumerate}
  \item
  Flush+Reload requires shared memory, cache-coherent architectures, and
    attacker proximity and Access to flush instruction.
  \item
    \begin{enumerate}
      \item Flush the cache.
      \item Victims fill cache with its own data.
      \item Reload data and measure access time.
    \end{enumerate}
  \item Limited by the latency of memory access and cache coherence protocols.
  \item It provides fine-grained data resolution, revealing memory access patterns.
  \item
    \begin{enumerate}
      \item Insertion Error: Mistakenly identifying a cache access as a result
        of manipulation when it's from another source.
      \item Deletion Error: Failing to observe a cache access that should have
        been evicted due to manipulation.
      \item Flip: Observing a cache access due to manipulation, but the timing
        measurement is inaccurate or misleading.
    \end{enumerate}

\end{enumerate}

\task[Flush+Reload Covert Channel]

\begin{enumerate}
  \item
\end{enumerate}

\task[Prime+Probe]

\begin{enumerate}
  \item
    \begin{enumerate}
      \item Execution on the same physical processor.
      \item High-precision timers.
      \item Cache manipulation capability.
      \item Knowledge of cache policies.
    \end{enumerate}
  \item
    \begin{enumerate}
      \item Prime the cache with an eviction set.
      \item Wait while victim evicts cache lines.
      \item Probe the eviction set data and measure access time.
    \end{enumerate}
  \item Limited by timer accuracy and memory latency.
  \item Reveals detailed memory access patterns.
  \item
    Transmission errors in Prime+Probe attacks—insertion, deletion, and
    flip—stem from noise, interference, or timing inaccuracies.
    Insertion errors arise when false positives mislead the attacker into
    thinking data is in the cache.
    Deletion errors occur when false negatives lead to missed cache data
    detection.
    Flip errors result from misinterpreting cache state changes due to noise or
    timing issues, leading to incorrect conclusions about accessed data.
\end{enumerate}

\task[L1D Prime-Probe Covert Channel]

\begin{enumerate}
  \item
\end{enumerate}

\end{document}
